A Java exception is an object that describes an exceptional (that is, error)
condition that has occurred in a piece of code. When an exceptional condition
arises, an object representing that exception is created and thrown in the
method that caused the error. That method may choose to handle the exception
itself, or pass it on. Either way, at some point, the exception is caught and
processed. Exceptions can be generated by the Java run-time system, or they
can be manually generated by your code. Exceptions thrown by Java relate to
fundamental errors that violate the rules of the Java language or the constraints
of the Java execution environment. Manually generated exceptions are
typically used to report some error condition to the caller of a method.
Java exception handling is managed via five keywords: try, catch, throw,
throws, and finally. Briefly, here is how they work. Program statements that
you want to monitor for exceptions are contained within a try block. If an
exception occurs within the try block, it is thrown. Your code can catch this
exception (using catch) and handle it in some rational manner. System-
generated exceptions are automatically thrown by the Java run-time system. To
manually throw an exception, use the keyword throw. Any exception that is
thrown out of a method must be specified as such by a throws clause. Any code
that absolutely must be executed after a try block completes is put in a finally
block.

All exception types are subclasses of the built-in class Throwable. Thus,
Throwable is at the top of the exception class hierarchy. Immediately below
Throwable are two subclasses that partition exceptions into two distinct
branches. One branch is headed by Exception. This class is used for
exceptional conditions that user programs should catch. This is also the class
that you will subclass to create your own custom exception types. There is an
important subclass of Exception, called RuntimeException.These are exceptional conditions that are internal to the application, and that the application usually cannot anticipate or recover from. These usually indicate programming bugs, such as logic errors or improper use of an API. For example, consider the application described previously that passes a file name to the constructor for FileReader. If a logic error causes a null to be passed to the constructor, the constructor will throw NullPointerException

The other branch is topped by Error, which  exceptional conditions that are external to the application, and that the application usually cannot anticipate or recover from. For example, suppose that an application successfully opens a file for input, but is unable to read the file because of a hardware or system malfunction. The unsuccessful read will throw java.io.IOError